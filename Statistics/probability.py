from math import factorial, sqrt, e
from scipy.stats import norm


def mult_prob(p, k):
    """
  Теорема умножения вероятностей.
  Вычисляет вероятность того, что событие с вероятностью p произойдет
  впервые на k-м испытании.

  Параметры:
      p (float): вероятность события (0 ≤ p ≤ 1)
      k (int): номер испытания (k ≥ 1)

  Возвращает:
      float: вероятность
  """
    q = 1 - p
    return p ** (k - 1) * q


print(mult_prob(0.8, 1))


def clss_prob(n, m):
    """
  Классическая теория вероятностей.
  Вычисляет число сочетаний из n по m.

  Параметры:
      n (int): общее количество элементов
      m (int): количество выбираемых элементов

  Возвращает:
      float: число сочетаний
  """
    return factorial(n) / (factorial(m) * factorial(n - m))


print(clss_prob(8, 2))


def bernoulli(n, p, k):
    """
  Формула Бернулли.
  Вычисляет вероятность k успехов в n независимых испытаниях.

  Параметры:
      n (int): количество испытаний
      p (float): вероятность успеха
      k (int): количество успехов

  Возвращает:
      float: вероятность
  """
    q = 1 - p
    Cn_k = factorial(n) / (factorial(k) * factorial(n - k))
    return Cn_k * p ** k * q ** (n - k)


print(bernoulli(500, 0.25, 45))


def laplace_local(n, k, p):
    """
  Локальная теорема Лапласа.
  Аппроксимация биномиального распределения при больших n.

  Параметры:
      n (int): количество испытаний
      k (int): количество успехов
      p (float): вероятность успеха

  Возвращает:
      float: приближенная вероятность
  """
    q = 1 - p
    sqr_n_p_q = sqrt(n * p * q)
    x = (k - n * p) / sqr_n_p_q
    return norm.pdf(x) / sqr_n_p_q


print(laplace_local(400, 45, 0.25))


def laplace_integral(n, p, k1, k2):
    """
  Интегральная теорема Лапласа.
  Вычисляет вероятность числа успехов в интервале [k1, k2].

  Параметры:
      n (int): количество испытаний
      p (float): вероятность успеха
      k1 (int): нижняя граница
      k2 (int): верхняя граница

  Возвращает:
      float: приближенная вероятность
  """
    q = 1 - p
    sqr_n_p_q = sqrt(n * p * q)
    x1 = (k1 - n * p) / sqr_n_p_q
    x2 = (k2 - n * p) / sqr_n_p_q
    return norm.cdf(x2) - norm.cdf(x1)


print(laplace_integral(100, 0.512, 51, 100))


def poisson(n, p, k):
    """
  Теорема Пуассона.
  Аппроксимация для редких событий (при больших n и малых p).

  Параметры:
      n (int): количество испытаний
      p (float): вероятность успеха
      k (int): количество успехов

  Возвращает:
      float: приближенная вероятность
  """
    λ = n * p
    return (λ ** k / factorial(k)) * e ** -λ


print(1 - (poisson(5000, 0.001, 0) + poisson(5000, 0.001, 1)))


def poisson_time(λ, t, k):
    """
  Распределение Пуассона для временных интервалов.
  Вероятность k событий за время t при интенсивности λ.

  Параметры:
      λ (float): интенсивность событий
      t (float): временной интервал
      k (int): количество событий

  Возвращает:
      float: вероятность
  """
    return ((λ * t) ** k / factorial(k)) * e ** (-λ * t)


print(1 - (poisson_time(3, 20 / 60, 0) + poisson_time(3, 20 / 60, 1) + poisson_time(3, 20 / 60, 2)))


def event(n, p):
    """
  Наивероятнейшее число успехов.
  Возвращает интервал наиболее вероятного числа успехов.

  Параметры:
      n (int): количество испытаний
      p (float): вероятность успеха

  Возвращает:
      str: интервал значений k
  """
    q = 1 - p
    return f'{n * p - q} <= k <= {n * p + p}'


print(event(2000, 0.001))


def deviation(n, p, ε):
    """
  Вероятность отклонения относительной частоты.
  Вычисляет вероятность отклонения более чем на ε.

  Параметры:
      n (int): количество испытаний
      p (float): вероятность успеха
      ε (float): величина отклонения

  Возвращает:
      float: вероятность
  """
    q = 1 - p
    a = ε * sqrt(n / (p * q))
    return 2 * (norm.cdf(a) - 0.5)


print(deviation(400, 0.5, 0.99))